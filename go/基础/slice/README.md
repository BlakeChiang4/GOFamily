# 切片

导读：

- 切片和数组的基本概念
- 切片数组的底层数据结构
- issues

## 切片和数组的基本概念
数组是拥有一段连续内存的数据结构，切片是存储了这个数据结构地址，长度以及容量的struct，这里俗称这种数据结构（类似切片）叫引用类型

不同长度的相同数据类型数组不是一个类型，比如 `[1]string{}`和`[2]string{}` 就是两个类型，但是切片没有这个烦恼，只要数据类型一致就是一种类型

切片的切片的容量是和切片的容量不一致的（比如这里的a 和 b），我们来看一个例子：

```go
package main

import "fmt"


func main() {
	a := []int{1, 2, 3, 4, 5, 6}
	b := a[2:5]
	fmt.Println(len(a), cap(a), len(b), cap(b))
}
```

output:`6, 6, 3, 4`

我猜你肯定以为b的容量也是6，但是不是，go规定，***切片只能向右看***，不能向左看，我们来说一下上面这个例子，a就不用说了，a的底层数据结构数组就是6个长度，所以a自然长度和容量都是6，但是b，它是切片的切片，遵从左闭右开的规则，它的长度是从index的2到4，也就是说是 `[3 4 5]`，自然它的长度就是3，这毫无疑问，又因为切片遵从“只能向右看容量”的规则，它的容量智能从index 2开始往后算，也就是 `6 - 2 = 4` 所以它的长度是3容量是4而不是6

如果想从b上获取所有容量的值，我们可以这么做`b[:cap(b)]` `=>` `[3 4 5 6]`


## 切片数组的底层数据结构
严格意义来说，go的切片不存在扩容，如果切片想要的数据量大于底层数组的容量时，那么系统会做两件事，开辟新的数组，给这个数组生成新的切片，之前的数组和切片并没有任何的改变，而且如果没有被引用了，还会被gc掉

切片的底层数据结构

slice的扩容规律

slice的边界检查消除以及优化


## issues
`问题一：` ***如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么***

一定要避免 a切片的更改造成的底层数据的改变，对b切片的结果造成影响，因为它们指向同一个数据底层

```go
a := []int{1,2,3}
b := a[:]

a[2] = 4

fmt.Println(a,b)
```
`[1 2 4] [1 2 4]`

`问题二：` ***怎样沿用扩容的思想对切片进行“缩容***

```go
a:= []int{1,2,3}
b := a[:2] // b = [1,2]

// 如果确定a的数据多余的没有任何的用途了
nb := make([]int,2)
copy(nb,b)
```
所谓扩容的思想，就是创造一个新的底层数据

`问题三：` ***nil切片和空切片(比如 []int{})的区别***

最大的区别就是指向的底层数组的地址不一样

- nil 压根就没有地址
- 空切片是有正儿八经的地址的，只不过这个地址指向的数组不占用空间，这个数组叫做zero数组，并且所有的空切片指向同一个数组就是这个zero数组，也可以说在go里，zero数组是唯一的存在，它存在的目的就是为了空切片

```go
a := [0]int{}
	fmt.Println(a)
	fmt.Println(unsafe.Sizeof(a)) // 0
```
空的数据是不占内存空间的，还有类似的，比如空的struct也是一样的

```go
a := struct{}{}
	fmt.Println(a)
	fmt.Println(unsafe.Sizeof(a)) // 0
```

`问题四：` ***slice和array的不同使用场景是什么***

`问题五：` ***padding（填充）是干什么的***

这主要牵涉到内存对齐


## 参考资料
- https://draveness.me/golang/
- https://www.jianshu.com/p/9ea2fba64f06
- https://chai2010.cn/advanced-go-programming-book
- https://blog.csdn.net/kevin_tech/article/details/122138489