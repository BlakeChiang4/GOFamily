# 其他内容
## go的引用类型和值类型

|引用类型|值类型|
|:---:|:---:|
|slice, interface, chan, map|array, func, struct, 数字类型, bool|

## 全局变量和局部变量

全局变量，引用类型分配在堆上，值类型分配在栈上

局部变量，一般分配在栈上，当局部对象过大的时候分配在堆上，如果对局部变量做逃逸分析，发现它逃逸到了堆上，那么就将其分配到堆上

## go 函数的执行顺序
init函数在一个包内的执行顺序：对同一个 `go` 文件的 `init()` 调用顺序是从上到下的，对同一个 `package` 中的不同文件,将文件名按字符串进行“从小到大”排序(数字排在前面),之后顺序调用各文件中的`init()`函数

对于不同的包，如果不相互依赖的话，按照main包中import的顺序调用其包中的`init()`函数，如果包存在依赖，例如：导入顺序 main –> A –> B –> C，则执行顺序为 C –> B –> A –> main

**go会先执行全局变量再执行init**，当然多包全局变量的初始化跟init的执行顺序是一致的

## go可比较类型

- 整数类型，bool，string 可比较
- 数组和结构体，需要具体的内容type一致才能比较
- 引用类型，除了slice，其它都是只能比较这些类型的地址
- slice 切片完全无法比较
- 接口比较的时候 , 只有这两个变量的动态类型 , 动态值都相等的时候 , 才是相等,或者两个接口值都是nil值（就是声明一下没有被实际赋值）

***对接口的解释**

```go

package main

import "fmt"

func main() {
	var t1 t
	var t2 t
	fmt.Println(a(t1) == a(t2))

}

type a interface {
	get()
}

type t struct{}

func (t) get() {}

```
其中t就是它的动态类型，t的值就是动态类型的值




