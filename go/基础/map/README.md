# map
导读：

- map的基本操作
- map基础知识
- map底层知识
- iussues
## map的基本操作

## map基础知识
映射的第一步就是把键值转化为哈希值（通常是一个很大的整数），然后根据哈希值的映射，把key-value本体，以及对应的哈希值存储在哈希筒中，go使用链表法充当哈希筒，当寻找值的时候，通过哈希计算，以及映射，先查找到哈希筒，然后使用哈希值的方式去寻找有没有符合的哈希值，如果找到了，那么再使用key原来的值二次比较，这一步主要是为了规避哈希碰撞，即：俩key算出来的哈希值是一样的这种行为。

因为存`==`这种行为，所以go语言map的键值是有局限的，**不可以是函数类型、字典类型和切片类型**，如果是接口类型，传入的实际类型也不能是函数，字典和切片，例如

```go
package main

func main() {
	_ = map[interface{}]int{
		[]int{1, 2}: 2, // panic
		"1": 1,
	}

}

```
**虽然，map的key可以设置为接口，但是最好不要这么干，因为会在运行时引入风险，比如上述代码就是风险。同样的，如果key是数组类型，亦或者是struct ，参数值都不能是函数，切片和map。** 无论被埋藏的有多深，都不能出现切片，map，函数这几种类型，比如说`[10][2][]string`，运行时都会看出来。

那么用什么类型的作为key值是比较推荐的呢？

这里有两个关键词：求哈希的速度，判断相等的速度，基本原理是越简单的类型速度越快，比如bool，int8，就比int64快，因为int8单个值只占了一个字节，int64是8个字节，所以越复杂的越慢，比如一个struct，因为求一个struct的哈希值，需要对里面的字段都进行哈希计算，然后合并起来，大大影响了速度，所以优先选用数值类型和指针类型(因为指针类型也就是一个16进制的正整数而已)，如果选string，最好短一些的比较好

在内存不爆炸的情况下，map的key是无限量的，随意添加。

map有一个最佳实践是使用形如 `value,ok := map[key]` 的 “comma OK” 的方法去获取map的值，OK的意义就是为了获得key是否存在这个map里，因为就算不存在，map也不会报错或者Panic，返回的是这个值的零值，比如int就返回0，那如果某一个key刚好结果是0就说不清了对吧，所以引入了这个 “comma ok” 机制，另外还存在一个不存在也不会Panic的操作，就是使用 `delete(map,key)` 的方法去删除key值

map的遍历跟slice一样，使用 m := range map 的方法，但是输出的顺序是不固定的，如果想输出稳定的值，可以将range改成普通的for循环，然后key值使用一个切片存储，这样的话，读取key值的时候顺序就是固定的了。



## map底层知识

map的语法在运行时转化为runtime.hmap来进行存储，hmap是一个struct，这个结构体拥有众多字段

```go
type hmap struct {
	count     int 
	flags     uint8
	B         uint8  
	noverflow uint16 
	hash0     uint32 
	buckets    unsafe.Pointer 
	oldbuckets unsafe.Pointer 
	nevacuate  uintptr        
	extra *mapextra 
}
``` 
- count:当前map的value个数，len返回的就是这个值
- flags:map的状态标志
- B: `2 ^ B = 桶数量`
- noverflow: 指的是 overflow的桶的数量
- hash0:哈希函数的种子值
- buckets:指向桶数组的指针
- oldbuckets:在map扩容阶段指向前一个桶的指针
- nevacuate:map扩容阶段充当扩容进度计数器 ，所有下标号小于nevacuate的桶都是已经完成了数据排空和迁移的操作的
- extra:【此字段是可选字段】如果有overflow的桶出现，该字段保证overflow的桶不会被gc，具体操作就是该字段存储所有指向overflow的桶的指针


拉链法。


map扩容。

map缩容。

## issues
`问题一：` **map 元素可以取地址吗？**

[不能](../其他内容/README.md#go可寻址类型)，map元素（例如ma["12"]）属于结果值，所以无法获取地址

`问题二：` **map可以并发读写吗？可以recover吗？**

map是线程不安全类型，读写得加互斥锁；被recover的Panic有几项是不能的：

- 数据竞争（比如：**对map进行并发读写**）
> 可以通过go的编译标记race对代码进行检测是否存在数据竞争
- 内存不足出现的Panic
- 死锁出现的Panic

`问题三：` **sync.Map 适合的场景，和map加锁的区别**

sync.Map在读多写少性能比较好，否则并发性能很差

> 有关sync.Map的[详细内容](../../工程/go标准库/sync.md#syncmap)

map不支持并发的读或者是写（go1.6以后就不支持并发的读和写了，之前的版本支持并发的读，但是不支持并发的写），所以map+锁性能在读多写少和读少写多，读和写一样多的情况下是一样的。

最优解是使用多把锁即：分段锁 的方式，并发读写，大幅提高性能

`问题四：` **在值为nil的字典上执行读操作会成功吗，那写操作呢？**

答案是 在值为nil的字典写会Panic，读是没问题的。

```go
package main

import "fmt"

func main() {
	var a map[int]int
	fmt.Println(a[1]) // 结果是int的一个初始值 0 
  a[0] = 1 // panic
}

```
`问题五：` **为什么不用向下寻址式？**

我们知道解决哈希碰撞的问题有向下寻址法，和链表法，这是因为哈希函数只能把数据尽可能分布的均匀，如果哈希函数的输出的范围大于输入的范围，这是不现实的，这就要求映射无穷多，这显然不可能，所以必然会有两个不同的key算出来的哈希值是相同的，那么如果很多key算出的哈希值都是一样的，这就出现了查找效率从O(1)下降到了O(n) 这就是所谓的哈希冲突。

> 这里提到的哈希值一样，有可能是后几位一样，也就是部分一样，比如后9位相同

向下寻址法的意思是：依次向下一位去探究是否是要找的哈希对，当然插入的时候也是这，向没有数据的地方插入，所以这种方法必须要使用数组这种结构，而且遍历的时候还得使用循环数组的这种思想 `index := hash("author") % array.len` ,开放寻址法有一个数据指标叫做 装载因子，就是说元素的个数/数组长度，一旦装载因子大于70 %乃至 90 % 基本上就倒退为了O(n)的时间复杂度，并且底层是数组的情况下，必须使用连续的内存地址，并且数组长度是有限的，并且大概率会发生内存padding的情况，因为kv要存储在一起，这就又造成了更大的浪费。

总结一下：不使用向下寻址使用拉链法的原因在于，1 可以利用碎片式的内存，2 不用内存padding造成浪费 3 原则上链表长度无限，可以无限增加。
## 参考资料
- 极客时间：go语言核心36讲
- 书籍：go语言精进之路